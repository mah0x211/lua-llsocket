local VERSION = tonumber(_VERSION:match('Lua (%d+%.%d+)'))

--- @class ConfigHeader
--- @field path string
--- @field f file*
--- @field headers table<string, boolean>
--- @field funcs table<string, boolean>
--- @field types table<string, boolean>
--- @field members table<string, boolean>
--- @field features table<string, string|boolean>
local ConfigHeader = {}
ConfigHeader.__index = ConfigHeader

--- new config.h
---@param path string
---@return ConfigHeader
function ConfigHeader.new(path)
    assert(type(path) == 'string', 'path must be string')

    local self = setmetatable({}, ConfigHeader)
    self.path = path
    self.f = assert(io.open(path, 'w+'))
    self.f:setvbuf('line')
    assert(self.f:write(([[
/**
 * this file is generated by configure.lua at %s
 */

 ]]):format(os.date())))

    self.headers = {}
    self.funcs = {}
    self.types = {}
    self.members = {}
    self.features = {}
    return self
end

function ConfigHeader:close()
    assert(self.f:close())
end

--- have_header define HAVE_{HEADER} in config.h
---@param name string
---@param have boolean
function ConfigHeader:have_header(name, have)
    local defname = name:gsub('[^%w]', '_'):upper()
    local lines = table.concat({
        ([[/* Define to 1 if you have the <%s> header file. */]]):format(name),
        (have and '#define HAVE_%s 1' or '/* #undef HAVE_%s */'):format(defname),
        '',
    }, '\n')

    self.headers[name] = have
    self.f:write(lines, '\n')
end

--- have_func define HAVE_{FUNC} in config.h
---@param name string
---@param have boolean
function ConfigHeader:have_func(name, have)
    local defname = name:gsub('[^%w]', '_'):upper()
    local lines = table.concat({
        ([[/* Define to 1 if you have the `%s' function. */]]):format(name),
        (have and '#define HAVE_%s 1' or '/* #undef HAVE_%s */'):format(defname),
        '',
    }, '\n')

    self.funcs[name] = have
    self.f:write(lines, '\n')
end

--- have_type define HAVE_{TYPE} in config.h
---@param name string
---@param have boolean
function ConfigHeader:have_type(name, have)
    local defname = name:gsub('[^%w]', '_'):upper()
    local lines = table.concat({
        ([[/* Define to 1 if you have the `%s' type. */]]):format(name),
        (have and '#define HAVE_%s 1' or '/* #undef HAVE_%s */'):format(defname),
        '',
    }, '\n')

    self.types[name] = have
    self.f:write(lines, '\n')
end

--- have_member define HAVE_{MEMBER} in config.h
---@param name string
---@param have boolean
function ConfigHeader:have_member(name, have)
    local defname = name:gsub('[^%w]', '_'):upper()
    local lines = table.concat({
        ([[/* Define to 1 if you have the the `%s' member. */]]):format(name),
        (have and '#define HAVE_%s 1' or '/* #undef HAVE_%s */'):format(defname),
        '',
    }, '\n')

    self.members[name] = have
    self.f:write(lines)
end

--- set_feature define the feature macro in testing
---@param name string
---@param value? string
function ConfigHeader:set_feature(name, value)
    assert(type(name) == 'string', 'name must be string')
    assert(type(value) == 'string' or value == nil,
           'value must be string or nil')
    self.features[name] = value or true
end

--- create_cfile create a cfile and return its path
---@param headers? string[]
---@param code? string
---@return string
function ConfigHeader:create_cfile(headers, code)
    assert(type(headers) == 'table' or headers == nil,
           'headers must be table or nil')
    assert(type(code) == 'string' or code == nil, 'code must be string or nil')

    local cfile = os.tmpname() .. '.c'
    local header = ''
    if headers then
        header = '#include <' .. table.concat(headers, '>\n#include <') .. '>'
    end
    local features = ''
    for name, value in pairs(self.features) do
        if type(type) == 'string' then
            features = features .. ('#define %s %s\n'):format(name, value)
        else
            features = features .. ('#define %s\n'):format(name)
        end
    end

    local src = ([[
%s

%s

int main(void) {
    %s
    return 0;
}]]):format(features, header, code or '')

    local f = assert(io.open(cfile, 'w+'))
    f:write(src)
    f:close()
    return cfile
end

local DECL_HEADER = 1
local DECL_FUNC = 2
local DECL_TYPE = 3
local DECL_MEMBER = 4
local DECLS = {
    [DECL_HEADER] = true,
    [DECL_FUNC] = true,
    [DECL_TYPE] = true,
    [DECL_MEMBER] = true,
}

--- exec will compile cfile and return true if success
---@param decl integer
---@param name string
---@param headers? string[]
---@param code? string
---@return boolean
function ConfigHeader:exec(decl, name, headers, code)
    assert(DECLS[decl],
           'decl must be DECL_HEADER, DECL_FUNC, DECL_TYPE or DECL_MEMBER')
    assert(type(name) == 'string', 'name must be string')
    assert(type(headers) == 'table' or headers == nil,
           'headers must be table or nil')
    assert(type(code) == 'string' or code == nil, 'code must be string or nil')

    local cfile = self:create_cfile(headers, code)
    local errfile = assert(os.tmpname())
    local errbuf = assert(io.open(errfile, 'r'))
    local cmd = table.concat({
        'gcc',
        '-I',
        '~/.lenv/current/include',
        cfile,
        '-o',
        'a.out',
        '2>',
        errfile,
    }, ' ')

    local ok = os.execute(cmd)
    os.remove(cfile)
    os.remove(errfile)
    if VERSION < 5.2 then
        ok = ok == 0
    end

    if ok then
        os.remove('a.out')
    else
        print(errbuf:read('*a'))
    end

    if decl == DECL_HEADER then
        self:have_header(name, ok)
    elseif decl == DECL_FUNC then
        self:have_func(name, ok)
    elseif decl == DECL_TYPE then
        self:have_type(name, ok)
    elseif decl == DECL_MEMBER then
        self:have_member(name, ok)
    end

    return ok == true
end

--- check_types check the types is available
---@param list string[]
---@param headers? string[]
---@param required? boolean
function ConfigHeader:check_types(list, headers, required)
    assert(type(list) == 'table', 'list must be table')
    assert(type(headers) == 'table' or headers == nil,
           'headers must be table or nil')
    assert(type(required) == 'boolean' or required == nil,
           'required must be boolean or nil')

    for _, name in ipairs(list) do
        assert(type(name) == 'string',
               'list#' .. tostring(_) .. ' must be string')

        local ok = self.types[name]
        if ok == nil then
            print(('check type %q'):format(name))
            ok = self:exec(DECL_TYPE, name, headers, ('%s x;'):format(name))
        end

        if not ok and required then
            error(('type %q is required'):format(name))
        end
    end
end

--- config_types_required check the types must be available
---@param list string[]
---@param headers? string[]
function ConfigHeader:config_types_required(list, headers)
    return self:check_types(list, headers, true)
end

--- config_types check the types is available
---@param list string[]
---@param headers? string[]
function ConfigHeader:config_types(list, headers)
    return self:check_types(list, headers, false)
end

--- check_funcs check the funcs is available
---@param list string[]
---@param headers? string[]
---@param required? boolean
function ConfigHeader:check_funcs(list, headers, required)
    assert(type(list) == 'table', 'list must be table')
    assert(type(headers) == 'table' or headers == nil,
           'headers must be table or nil')
    assert(type(required) == 'boolean' or required == nil,
           'required must be boolean or nil')

    for _, name in ipairs(list) do
        assert(type(name) == 'string',
               'list#' .. tostring(_) .. ' must be string')

        local ok = self.funcs[name]
        if ok == nil then
            print(('check function %q'):format(name))
            ok = self:exec(DECL_FUNC, name, headers,
                           ('void (*function_pointer)(void) = (void (*)(void))%s;'):format(
                               name))
        end

        if not ok and required then
            error(('func %q is required'):format(name))
        end
    end
end

--- config_funcs_required check the funcs must be available
---@param list string[]
---@param headers? string[]
function ConfigHeader:config_funcs_required(list, headers)
    return self:check_funcs(list, headers, true)
end

--- config_funcs check the funcs is available
---@param list string[]
---@param headers? string[]
function ConfigHeader:config_funcs(list, headers)
    return self:check_funcs(list, headers, false)
end

--- check_headers check the headers is available
---@param list string[]
---@param found_headers? string[]
---@param required boolean
function ConfigHeader:check_headers(list, required, found_headers)
    assert(type(list) == 'table', 'list must be table')
    assert(type(found_headers) == 'table' or found_headers == nil,
           'found_headers must be table or nil')
    assert(type(required) == 'boolean' or required == nil,
           'required must be boolean or nil')
    found_headers = found_headers or {}

    for _, name in pairs(list) do
        assert(type(name) == 'string',
               'list#' .. tostring(_) .. ' must be string')

        local ok = self.headers[name]
        if ok == nil then
            print(('check header %q'):format(name))
            ok = self:exec(DECL_HEADER, name, {
                name,
            })
        end

        if ok then
            found_headers[#found_headers + 1] = name
        elseif required then
            error(('header %q is required'):format(name))
        end
    end
end

--- config_headers_required check the headers must be available
---@param list table<string, boolean>
---@param found_headers? string[]
function ConfigHeader:config_headers_required(list, found_headers)
    self:check_headers(list, true, found_headers)
end

--- config_headers check the headers is available
---@param list string[]
---@param found_headers? string[]
function ConfigHeader:config_headers(list, found_headers)
    self:check_headers(list, false, found_headers)
end

--- config_fields check the members of structs is available
---@param types table<string, string[]>
---@param headers? string[]
---@param required? boolean
function ConfigHeader:check_fields(types, headers, required)
    assert(type(types) == 'table', 'types must be table')
    assert(type(headers) == 'table' or headers == nil,
           'headers must be table or nil')
    assert(type(required) == 'boolean' or required == nil,
           'required must be boolean or nil')

    for name, fields in pairs(types) do
        self:check_types({
            name,
        }, headers, required)

        for _, field in ipairs(fields) do
            assert(type(field) == 'string',
                   'types.' .. name .. '#' .. tostring(_) .. ' must be string')

            local field_name = name .. '.' .. field

            local ok = self.members[field_name]
            if ok == nil then
                print(('check member field %q'):format(field_name))
                ok = self:exec(DECL_TYPE, field_name, headers,
                               ('%s x; (void)x.%s;'):format(name, field))
            end

            if not ok and required then
                error(('%q is required'):format(field_name))
            end
        end
    end
end

--- config_fields check the members of structs must be available
---@param types table<string, string[]>
---@param headers? string[]
function ConfigHeader:config_fields_required(types, headers)
    self:check_fields(types, headers, true)
end

--- config_fields check the members of structs is available
---@param types table<string, string[]>
---@param headers? string[]
function ConfigHeader:config_fields(types, headers)
    self:check_fields(types, headers, false)
end

do
    local path = 'src/config.h'
    local cfg = ConfigHeader.new(path)
    cfg:set_feature('_GNU_SOURCE')

    cfg:config_headers({
        -- -- headers on linux
        -- 'linux/if.h',
        -- 'linux/if_packet.h',
        -- -- headers on other unix
        -- 'net/if_dl.h',
    })

    cfg:config_funcs({
        'sendfile',
        'accept4',
    }, {
        'sys/types.h',
        'sys/socket.h',
        'sys/sendfile.h',
    })

    cfg:config_fields({
        ['struct sockaddr'] = {
            'sa_len',
        },
    }, {
        'sys/socket.h',
        'sys/types.h',
    })

    cfg:close()
    print('done')
end
